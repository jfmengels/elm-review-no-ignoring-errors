[{"name":"NoIgnoringErrors","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when error details are not being used.\n\n    config =\n        [ NoIgnoringErrors.rule\n        ]\n\n\n## Fail\n\n    notificationMessage =\n        case foo of\n            Ok () ->\n                \"Success!\"\n\n            Err _ ->\n                \"Failure!\"\n\n\n## Success\n\n    notificationMessage =\n        case foo of\n            Ok () ->\n                \"Success!\"\n\n            Err errorMessage ->\n                \"Failed to make this work because \" ++ errorMessage\n\nAs shown in the following example, the rule will only check whether a wildcard (`_`) is used for `Err`. I recommend enabling the\n[`NoUnused.Patterns`](https://package.elm-lang.org/packages/jfmengels/elm-review-unused/latest/NoUnused-Patterns) rule\nto help get you to the state where the noise is removed.\n\n    notificationMessage =\n        case foo of\n            Ok () ->\n                \"Success!\"\n\n            Err errorMessage ->\n                -- `errorMessage` is not used, but the rule only checks whether a wildcard is being used.\n                \"Failure!\"\n\nIn some cases, you will genuinely only care about whether something has failed or not. In those cases, you can transform the result\nin a way where you explicitly show that you don't care about the error.\n\n    hasFailed =\n        case Result.mapError (\\_ -> ()) foo of\n            Ok data -> ...\n            Err () -> ...\n\nTo do the above, I recommend using [`Result.mapError`](https://package.elm-lang.org/packages/elm/core/latest/Result#mapError) or [`Result.toMaybe`](https://package.elm-lang.org/packages/elm/core/latest/Result#toMaybe),\nand to use them at the earliest possible convenience, such as when you are creating the `Task`, so that your the associated constructor shows you will ignore the error.\n\n    type Msg\n        = UserClickedOnSend\n        | GotServerResponse (Result () Data)\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            UserClickedOnSend ->\n                ( model\n                , Http.get\n                    { url = \"https://elm-lang.org/assets/public-opinion.txt\"\n                    , expect =\n                        Http.expectString\n                            (Result.mapError (\\_ -> ()) >> GotServerResponse)\n                    }\n                )\n\n            GotServerResponse (Ok data) ->\n                ( { model | data = data }, Cmd.none )\n\n            GotServerResponse (Err ()) ->\n                ( { model | errorWasReceived = True }, Cmd.none )\n\n\n## When (not) to enable this rule\n\nThis rule is still experimental. I am trying to figure out if this error is always useful or how to tweak it to remove\nfalse positives and discover more cases where errors are ignored.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-no-ignoring-errors/preview --rules NoIgnoringErrors\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]}]